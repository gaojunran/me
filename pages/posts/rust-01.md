---
title: Rust for Rustaceans - 01 讨论内存
date: 2025-04-29T00:00:00Z
lang: zh
duration: 12min
type: note
---

## 讨论内存

1. 什么是**值**（`value`）？

Rust 中的一个**值**是由类型以及该类型的值域中的一个元素组成的组合。用其类型的表示方法，值可以转成字节的序列。

2. 什么是**指针**？

指针是一块存储地址的内存区域。我们可以解引用指针来访问它指向的内存区域的值。同一个指针可以存进多个变量里。

```rust
let string = "Hello world";
```

在这个例子中，即使我们把一个字符串类型的值赋值给变量，这个变量的真实值是一个指向字符串第一个字符的指针（这个胖指针还包括字符串长度），不是这个字符串值本身。

---

我们可以从两个视角「高层模型」和「底层模型」来讨论程序。

### 高层模型

在「高层模型」中，我们不把变量看成是存储字节的空间。相反，我们认为他们只是在程序中被实例化、移动和使用时**赋予值的名称**。

当你将一个值赋给变量时，这个值从那一刻起就由该变量命名。当之后访问这个变量时，你可以想象**从上一次访问该变量处画一条线到这次访问**，这条线表示这两次访问之间存在依赖关系。如果变量中的值被移动了，那么就无法再从它画出任何线了。

在这种模型中，**变量只在它持有一个合法值时才存在**；你无法从一个未初始化或已经被移动的变量中画出依赖线，因此从效果上讲，它等同于不存在。

基于这个模型，你的整个程序由许多这样的依赖线（通常称为「流」）组成，**每一条流都追踪某个特定值实例的生命周期。**当出现分支时，流可以分叉或合并，每一个分支都代表该值的一个独立生命周期。

编译器可以检查，在程序的任意时刻，所有可能并行存在的流是否彼此兼容。
例如，**不能同时存在两个对同一个值拥有可变访问权限的并行流；也不能存在一个借用了值的流，而没有另一个拥有该值的流**。

```rust
let mut x;
// 此行是非法的，借用检查器
// 无法从任何地方“画出”值流
assert_eq!(x, 42);
// 这行开始了一个值流
x = 42;
// 创建了一个共享引用
// 从 x 到 y 又开始了一条新的“共享流”
let y = &x;
// 对 x 的可变访问
// 创建了一条新的“独占流”
x = 43;
// 独占流和共享流并行存在
assert_eq!(*y, 42);
```

借用检查器分析程序中所有变量的“值流”（flows）：

一条是从`x = 42`到`let y = &x;`到 `assert_eq!(*y, 42)`的共享流；

一条是从`x = 42`到`x = 43`的独占流。

当它检查`x = 43`行的独占流时，它发现还有一条并行存在的共享流还没结束（因为它在最后一行还被用了）。

> 你需要充分理解并行流的概念，这段代码报错并非因为既有「可变访问」又有「共享引用」，而是他们在一个特定时机同时存在。例如如果删去最后一行，程序正常编译通过。

### 底层模型

```rust
let x: usize;
x = 6;
```

`x`是`usize`类型，因此会在栈上为它分配一段内存空间，足够容纳一个`usize`的值；当你执行`x = 6`时，那个为`x`保留的内存空间就会被写入代表数字`6`的位（bits）；`&x`是对变量`x`的引用，因为`x`的地址是固定的，所以`&x`的值始终不变。

> 思考：假如`x`是一个任意类型，有哪些办法可以让`&x`的值改变？

高层模型的概念是 Rust 与 C 等相对底层的语言不同的地方。但你在思考代码时，应该同时考虑这两种心智模型。

---

### 栈空间

栈是你程序**在函数调用中用作临时空间**的一段内存。

每当一个函数被调用时，会在栈的顶部分配一块连续的内存，称为栈帧（frame）。在栈的底部，是`main`函数的栈帧；随着函数调用其他函数，新的栈帧会不断压入到栈上。

一个函数的栈帧包含该函数中的所有变量，以及它所接收的参数。当函数返回时，它的栈帧会被回收。函数局部变量的值在内存中的那部分字节不会立即被清除，但访问这些内容是不安全的，因为这块内存可能已被后续函数的栈帧重写。即便它没有被重写，其中可能也包含不再合法使用的值，例如一些在函数返回时被移动的值。

### 堆空间

堆是一个内存池，它**不依赖于程序当前的调用栈**。

存放在堆内存中的值**会一直存在，直到你显式地释放它们**。当你希望一个值的生命周期超出当前函数栈帧的生命周期时，堆就非常有用。比如，如果某个值是函数的返回值，调用者可以在它自己的栈上为该返回值预留空间，这样被调用的函数就可以在返回前将该值写进去。

但如果你希望将该值发送到另一个线程（这个线程可能与当前线程没有任何共享的栈帧），你就可以把它存放到堆上。

堆允许你显式分配连续的一段内存。当你进行这种分配时，你会获得一个**指向这段内存开头的指针**。这段内存将会保留给你使用，直到你显式地释放它；
这个过程通常被称为释放（free），这个术语源于 C 标准库中的函数 `free`。

在 Rust 中，和堆交互的主要机制是 `Box` 类型。当你写 `Box::new(value)` 时，这个 `value` 会被放到堆上， 你得到的是一个指向该堆值的 `Box<T>`（一个智能指针）。当这个 `Box` 被销毁（`drop`）时，对应的堆内存也会被自动释放。

如果你忘了释放堆内存，它就会永远留在那里，
久而久之，你的程序可能会内存泄漏。不过，在某些场景下，你可能确实想要故意泄漏内存。比如说，你有一个只读配置对象（read-only configuration），整个程序都需要访问它，你可以把它放在堆上，然后使用 `Box::leak` 显式泄漏它，从而获得一个 `'static` 生命周期的引用。

## 静态内存区

静态内存实际上是一个总称，用于指代程序编译后位于文件中的几个紧密相关的区域。当程序执行时，这些区域会**自动加载到程序的内存**中。静态内存中的值在**整个程序执行期间都存在**。程序静态内存包含程序的二进制代码，通常被映射为只读。随着程序的执行，程序会逐条指令遍历文本段的二进制代码，并在调用函数时跳跃。静态内存还包含使用静态关键字声明的变量的内存，以及代码中的某些常量值，如字符串。

Rust 中的特殊生命周期`'static`表示一个值在程序的整个生命周期内都存在。但**存在 `'static` 生命周期的引用，可能并不是指向静态内存**。 不过这个名字仍然合理： 一旦你创建了一个 `'static` 生命周期的引用，对程序的其余部分来说，
它所指向的内容就「等同于」在静态内存中， 因为这个引用可以任意长时间地被使用，只要你的程序还活着。

在实际写 Rust 程序时，你遇到 `'static` 的频率远高于真正的静态内存（例如通过 `static` 关键字声明的变量）。这是因为 `'static` 经常**出现在 trait 约束中**。

举个例子：`T: 'static` 表示类型参数 `T` 的生命周期可以长到等同于整个程序的生命周期。换句话说，这个约束要求 `T` 是“拥有所有权且自给自足的”：要么 `T` 不借用任何非 `'static` 的值，要么它借用的所有内容本身也是 `'static`，也就是**直到程序结束都不会被释放**。

一个使用 `'static` 作为 trait 约束的好例子是`std::thread::spawn` 函数（用于创建新线程）：它要求你传进去的闭包是 `'static`， 因为新线程的生命周期**可能比当前线程更长**，那么它就**不能引用当前线程栈上的任何值**（因为这些值会随着线程结束而被销毁）。新线程**只能引用那些生命周期足够长的值**，即能活到程序结束的值。

`const` 关键字声明的是一个常量项。常量项在**编译时就完全被计算出来**，所有引用它的代码，**在编译期间就会被替换为它的值**。常量**没有实际的内存地址或存储空间**（它不是一个「位置」）。可以把 `const` 想象成一个值的别名，而不是一个变量。
